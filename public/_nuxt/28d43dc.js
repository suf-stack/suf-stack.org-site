(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{277:function(e,t,n){"use strict";n.r(t);var o={head:{title:"About",meta:[{hid:"description",name:"description",content:"SUF-Stack - Serverless, Universal, Full Stack - About the architecture"}]}},r=n(36),component=Object(r.a)(o,(function(){var e=this,t=e._self._c;return t("div",[t("section",{staticClass:"section"},[t("div",{staticClass:"container"},[t("h1",{staticClass:"title"},[e._v("What is the SUF Stack?")]),e._v(" "),e._m(0),e._v(" "),t("p",[e._v("\n        I've been building web apps for a while, and was\n        never quite happy with the trade-offs involved in the choice of architecture.\n        Frameworks and architectures would only really optimize for one of: users, developers, or\n        infrastructure, and compromise on the others.\n      ")]),e._v(" "),t("p",[e._v("\n        Now, there's a combination of technologies that when combined into a single architecture\n        combine to combine to avoid many of those trade-offs.  I've been using this\n        in production for a few years now, and have found it effective in quickly building\n        performant, scalable web apps.\n      ")]),e._v(" "),t("p",[e._v("\n        This site is about sharing the SUF Stack architecture with other creators to help enable\n        them to create great things.\n      ")]),e._v(" "),t("h3",{staticClass:"subtitle"},[e._v("\n        A SUF-Stack app is:\n      ")]),e._v(" "),t("div",{staticClass:"content"},[t("ul",[t("li",[t("a",{directives:[{name:"scroll-to",rawName:"v-scroll-to",value:"#section-serverless",expression:"'#section-serverless'"}],attrs:{href:"#"}},[e._v("Serverless")]),e._v("\n            - optimized for the cloud\n          ")]),e._v(" "),t("li",[t("a",{directives:[{name:"scroll-to",rawName:"v-scroll-to",value:"#section-universal",expression:"'#section-universal'"}],attrs:{href:"#"}},[e._v("Universal")]),e._v("\n            - optimized for the user\n          ")]),e._v(" "),t("li",[t("a",{directives:[{name:"scroll-to",rawName:"v-scroll-to",value:"#section-fullstack",expression:"'#section-fullstack'"}],attrs:{href:"#"}},[e._v("Full Stack")]),e._v("\n            - optimized for the developer\n          ")])])]),e._v(" "),t("h2",{staticClass:"subtitle",attrs:{id:"section-serverless"}},[t("b-icon",{attrs:{icon:"cloud-outline"}}),e._v("\n        Serverless\n      ")],1),e._v(" "),t("p",[e._v("\n        A SUF-Stack App should be optimized for its deployment on the cloud.  This means optimizing\n        costs to only pay for the compute which one is using.  And it should mean worry free server provisioning\n        and maintenance.\n      ")]),e._v(" "),e._m(1),e._v(" "),t("p",[e._v("\n        The starter template deploys to AWS Lambda, behind AWS API Gateway.  It also deploys static\n        assets on S3 (using content-based hashes in names to bust caches) and leverages CloudFront\n        to both serve content close to users and\n        to only send HTTP requests which need a dynamic evaluation to the backend in Lambda.\n        CloudFront is configured to use HTTP/2 for faster transport, and to take advantage of compression\n        to further reduce bandwidth usage.\n        Furthermore, logging is written to AWS CloudWatch in JSON, for parsing in\n        CloudWatch Insights dashboards.\n      ")]),e._v(" "),t("p",[e._v("\n        FaaS-based HTTP endpoints have a known issue of taking longer to serve requests\n        if the function has not been called for a while.  To solve this cold-start problem, and to\n        provide better uptime monitoring, we configure an AWS Route 53 HealthCheck to repeatedly query\n        the backend from a variety of global locations which keeps the lambda function warm.\n        We also deploy the application as a single function to simplify routing and so that there is\n        only a single function to keep warm.\n      ")]),e._v(" "),t("b-message",{attrs:{type:"is-warning","has-icon":""}},[t("p",[e._v("\n          Known Limitations:\n        ")]),e._v(" "),t("p",[e._v("\n          - Web requests must not take longer than a few seconds (30 seconds for AWS).\n          This is also a good practice for human-facing user experience, and you should consider\n          a different backend infrastructure to run long-running processes.\n        ")]),e._v(" "),t("p",[e._v("\n          - The bundled application should not be too large (250MB for AWS).  Which means that your\n          application code should just be code.  Data should be stored in something like a database.\n          And images and video should be stored elsewhere and linked in to the application.\n          I'd recommend a service like "),t("a",{attrs:{href:"https://cloudinary.com/"}},[e._v("cloudinary")]),e._v(" for images\n          and video.\n        ")]),e._v(" "),t("p",[e._v("\n          - Streaming HTTP services like web sockets and WebRTC will require, a different, more\n          specialized, deployment.\n        ")])]),e._v(" "),t("h2",{staticClass:"subtitle",attrs:{id:"section-universal"}},[t("b-icon",{attrs:{icon:"vector-difference"}}),e._v("\n        Universal\n      ")],1),e._v(" "),t("p",[e._v("\n        A SUF-Stack app should be optimized for its users.  This means being a universal application\n        where the first page has HTML generated on the server, for the fastest possible render,\n        and where subsequent pages are generated on the browser, leveraging the techniques\n        from single-page apps.  Being universal helps with automated parsing of your web pages, as\n        for search engines and other web spiders.\n      ")]),e._v(" "),t("p",[e._v("\n        In addition, web application code should be delivered with long cache times to speed\n        up later visits to the web application, with those bundles named automatically with\n        hashes of their content so as to do cache busting in a natural manner.\n      ")]),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),t("b-message",{attrs:{type:"is-warning","has-icon":""}},[t("p",[e._v("\n          Known Limitations:\n        ")]),e._v(" "),t("p",[e._v("\n          Some UX-related packages only work in the browser, and may need to be loaded\n          via the Vue "),t("a",{attrs:{href:"https://vuejs.org/v2/api/#mounted"}},[e._v("mounted")]),e._v(" hook\n        ")]),e._v(" "),t("p",[e._v("\n          Some bugs may be harder to trace when your app is in universal mode.  You may need\n          to temporarily "),t("a",{attrs:{href:"https://nuxtjs.org/api/configuration-mode"}},[e._v("change")]),e._v("\n          your app to a single-page-app to debug.\n        ")]),e._v(" "),t("p",[e._v("\n          Universal apps run code every time that a page is requested.  This lets a web application\n          show different content to different viewers, but it is not as efficient as a static page.\n          If you are only rendering static content, you don't need to build a web app, and should\n          use a "),t("a",{attrs:{href:"https://www.staticgen.com/"}},[e._v("static site generator")]),e._v(".\n        ")])]),e._v(" "),t("h2",{staticClass:"subtitle",attrs:{id:"section-fullstack"}},[t("b-icon",{attrs:{icon:"language-javascript"}}),e._v("\n        Full Stack\n      ")],1),e._v(" "),t("p",[e._v("\n        A SUF-Stack app should be optimized for developers.  That is, it should minimize the\n        number of languages needed to write the full application to just Javascript (or Typescript).\n      ")]),e._v(" "),t("p",[e._v("\n        It should have a clearly defined frontend using a mature framework, so that one\n        can count on finding answers to common problems.  There should also be features such\n        as hot-reloading during development and a robust set of options for CSS and UX component\n        frameworks.\n      ")]),e._v(" "),t("p",[e._v("\n        A major differentiator between a SUF-Stack web app and a Jamstack app is the use of a\n        proper backend in SUF.  This means either Express.js or Koa.js or similar backend designed\n        to be run server-side, with access to secret credentials, and priviledged code.  It's often\n        simpler and easier to just write your own backend API routes using Node.js code, especially when interacting\n        with databases and external APIs.\n      ")]),e._v(" "),t("p",[e._v("\n        The starter template puts backend code into its own folder, and optimizes the development experience\n        for it.  The backend is deployed as part of the same serverless function as the frontend\n        but with priviledged values (secrets) available to it via environment variables.  One can develop\n        the frontend and backend for a given feature in the same code base, and ensure that they are always\n        deployed in sync.  For development, the frontend and the backend execute locally for a\n        fully functional local development environment.\n      ")]),e._v(" "),t("b-message",{attrs:{type:"is-warning","has-icon":""}},[t("p",[e._v("\n          Known Limitations:\n        ")]),e._v(" "),t("p",[e._v("\n          Not all developers or applications need a backend.  For those situations, it may not be\n          necessary to use the SUF-Stack.\n        ")])]),e._v(" "),t("h2",{staticClass:"subtitle"},[e._v("Next Steps")]),e._v(" "),t("p",[e._v("\n        If the SUF-stack sounds like what you need, then you can\n        "),t("nuxt-link",{attrs:{to:"/get-started"}},[e._v("get started")]),e._v(" today!\n      ")],1),e._v(" "),t("hr"),e._v(" "),t("h2",{staticClass:"subtitle"},[e._v("Some History and Context")]),e._v(" "),t("p",[e._v("\n        The first websites were hand-coded HTML files hosted on individual web servers.  For creators\n        of those sites, it often meant lots of markup repetition and other inefficiencies.  For users\n        of such sites, the content would tend to get stale and lose relevance.  For the system administrators\n        in charge of the infrastructure, there would be a worry about keeping the sites online, especially\n        when there would be a surge in users for a popular site.\n      ")]),e._v(" "),t("p",[e._v("\n        Next came the first generation of web applications.  These provided dyamic content via server-side\n        code, and unlocked the web as a vehicle for eCommerce, search engines, and more.  Users were\n        delighted by the new functionality, and would tolerate the sometimes slow loading times.  Creators\n        were empowered by their new capabilities and eagerly dove into a raft of new languages and frameworks.\n        However the infrastructure demands became complex and error-prone.\n      ")]),e._v(" "),t("p",[e._v("\n        Single-page apps emerged next, offering much richer experiences for users by leveraging\n        browser capabilities to react quickly to user inputs, and unlock emerging web standards.\n        However, for creators this created the need for different languages and technologies for the\n        frontend and backend, resulting in diverging skills and split teams.  Infrastructure needs,\n        which had only started to simplify via public cloud providers, became complex balances\n        between versioned deployments of the frontend and backend, and the unique scaling needs of each.\n      ")]),e._v(" "),t("p",[e._v("\n        The next set of web application architectures solve specific weaknesses.  Universal apps\n        which render content both on the server and in the browser aid in search discoverability and speed\n        but suffer from complex deployments.  Static site generators sacrifice dynamic backends to\n        optimize for distributed and cached infrastructure, and fast page speeds for the user.  The Jamstack\n        adds more dynamic content to static sites, but still suffers from a lack of a backend with priviledged\n        code.\n      ")])],1)])])}),[function(){var e=this,t=e._self._c;return t("h2",{staticClass:"subtitle"},[e._v("by "),t("a",{attrs:{href:"https://bradito.me/"}},[e._v("Brad Ito")])])},function(){var e=this,t=e._self._c;return t("p",[e._v("\n        We've been using the \n        "),t("a",{attrs:{href:"https://serverless.com/",rel:"nofollow noopener",target:"_blank"}},[e._v("Serverless Framework")]),e._v(".\n        It configures deployment of apps to deploy as HTTP endpoints that call function-as-a-service (FaaS)\n        code on a variety of cloud providers.  It also provides a rich ecosystem of plugins and tools\n        which one can leverage to expand its capabilities.  In the AWS context, it actually configures\n        AWS CloudFormation, and can thus be extended to configure pretty much anything on AWS.\n      ")])},function(){var e=this,t=e._self._c;return t("p",[e._v("\n        The starter template uses\n        "),t("a",{attrs:{href:"https://nuxtjs.org/"}},[e._v("Nuxt.js")]),e._v(" to orchestrate "),t("a",{attrs:{href:"https://webpack.js.org/"}},[e._v("webpack")]),e._v("\n        to build universal applications.  This means that you just need to focus on writing your app\n        and Nuxt.js will take care of wiring it up into a universal app, without you having to worry\n        about how to make that happen.  There are some subtleties about making relative URL resolution\n        consistent which the starter template takes care of for you.\n      ")])},function(){var e=this,t=e._self._c;return t("p",[e._v("\n        Another great feature that Nuxt.js exposes from webpack is the\n        "),t("a",{attrs:{href:"https://nuxtjs.org/api/configuration-build/#analyze"}},[e._v("analyze")]),e._v(" build option\n        which lets one visualize how many bytes your code and library dependencies are using.\n        One should use this to guide optimizing your web app size to speed things up for your users.\n        There is also a great "),t("a",{attrs:{href:"https://github.com/nuxt-community/awesome-nuxt"}},[e._v("variety")]),e._v("\n        of Nuxt.js modules which one can use.\n      ")])}],!1,null,null,null);t.default=component.exports}}]);